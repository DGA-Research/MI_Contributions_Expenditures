#!/usr/bin/env python3
"""
Utility to extract contribution and direct expenditure data from the
“Candidate Report View and Schedules” PDF generated by Michigan’s
campaign finance system.

The parser relies on the layout that appears in the supplied document:
  • Contributions Schedule begins around page 3.
  • Direct Expenditures Schedule begins around page 431.

Run “python mi_report_parser.py --help” for usage information.
"""

from __future__ import annotations

import argparse
import csv
import json
import logging
import re
from dataclasses import dataclass, field
from decimal import Decimal, InvalidOperation
from pathlib import Path
from typing import Iterable, List, Optional, Sequence, Tuple

from pypdf import PdfReader


_CONTRIBUTION_ENTRY_PATTERN = re.compile(r"Receipt\s+\d{2}-\d+")
_IN_KIND_ENTRY_PATTERN = re.compile(r"Receipt ID:\s+\d{2}-\d+")
_OTHER_RECEIPT_ENTRY_PATTERN = re.compile(r"Receipt ID:\s+\d{2}-\d+")
_FUNDRAISER_ENTRY_PATTERN = re.compile(r"Fundraiser ID:\s+\d{2}-\d+")
_EXPENDITURE_ENTRY_PATTERN = re.compile(r"Expense ID:\s+\d{2}-\d+")
_DATE_LINE_PATTERN = re.compile(
    r"Date\s+(\d{2}/\d{2}/\d{2})\s+Amount:\s*([\d,]+\.\d{2})\s+Cumulative\s+([\d,]+\.\d{2})"
)
_SOURCE_TYPE_OVERRIDES = {"PAC": "Individual", "XPAC": "PAC"}


def _parse_decimal(value: str) -> Optional[Decimal]:
    """Convert a currency string such as “1,234.56” to Decimal."""
    value = value.replace(",", "").strip()
    if not value:
        return None
    try:
        return Decimal(value)
    except InvalidOperation:
        logging.debug("Unable to parse decimal from %r", value)
        return None


def _decimal_to_string(value: Optional[Decimal]) -> Optional[str]:
    if value is None:
        return None
    return format(value.quantize(Decimal("0.01")), "f")


def _normalize_source_type(value: Optional[str]) -> Optional[str]:
    if value is None:
        return None
    stripped = value.strip()
    mapped = _SOURCE_TYPE_OVERRIDES.get(stripped.upper())
    if mapped is not None:
        return mapped
    return stripped


def _split_contributor_name(name: Optional[str]) -> Tuple[Optional[str], Optional[str]]:
    if not name or "," not in name:
        return None, None
    last, first = name.split(",", 1)
    last = last.strip() or None
    first = first.strip() or None
    return last, first


def _looks_like_address(line: str) -> bool:
    """Best-effort signal that a line represents part of a postal address."""
    if not line or ":" in line:
        return False
    if re.match(r"\d", line):
        return True
    if re.search(r",\s*(MI|Michigan)\b", line, flags=re.IGNORECASE):
        return True
    if "PO BOX" in line.upper() or "P.O." in line.upper():
        return True
    return False


def _clean_line(line: str) -> str:
    return " ".join(line.replace("\xa0", " ").strip().split())


def _combine_pages(
    pages: Sequence[Tuple[int, str]]
) -> Tuple[str, Sequence[int], Sequence[int]]:
    """
    Join the text from multiple pages into a single string and track the starting
    character offset for each page so we can map entries back to page numbers.
    """
    pieces: List[str] = []
    positions: List[int] = []
    page_numbers: List[int] = []
    cursor = 0

    for page_number, text in pages:
        positions.append(cursor)
        page_numbers.append(page_number)
        pieces.append(text)
        # Add 1 to account for the newline inserted by the join.
        cursor += len(text) + 1

    combined = "\n".join(pieces)
    return combined, positions, page_numbers


def _locate_page(char_index: int, positions: Sequence[int], pages: Sequence[int]) -> int:
    """
    Given a character offset in the combined text, return the 1-based PDF page
    number that contains the character.
    """
    import bisect

    idx = bisect.bisect_right(positions, char_index) - 1
    if idx < 0:
        idx = 0
    return pages[idx] + 1  # Convert zero-based index to PDF page number.


@dataclass
class ContributionEntry:
    receipt_id: str
    category: Optional[str] = None
    source_type: Optional[str] = None
    date: Optional[str] = None
    amount: Optional[Decimal] = None
    cumulative_amount: Optional[Decimal] = None
    contributor_name: Optional[str] = None
    contributor_last_name: Optional[str] = None
    contributor_first_name: Optional[str] = None
    occupation: Optional[str] = None
    employer: Optional[str] = None
    address_lines: List[str] = field(default_factory=list)
    fundraising_event: Optional[str] = None
    employer_address: List[str] = field(default_factory=list)
    page_number: Optional[int] = None
    extra: dict = field(default_factory=dict)
    raw_text: Optional[str] = None

    def to_json_dict(self, include_raw: bool = False) -> dict:
        data = {
            "receipt_id": self.receipt_id,
            "category": self.category,
            "source_type": self.source_type,
            "date": self.date,
            "amount": _decimal_to_string(self.amount),
            "cumulative_amount": _decimal_to_string(self.cumulative_amount),
            "contributor_name": self.contributor_name,
            "contributor_last_name": self.contributor_last_name,
            "contributor_first_name": self.contributor_first_name,
            "occupation": self.occupation,
            "employer": self.employer,
            "address_lines": self.address_lines,
            "fundraising_event": self.fundraising_event,
            "employer_address": self.employer_address,
            "page_number": self.page_number,
        }
        if self.extra:
            data["extra"] = self.extra
        if include_raw:
            data["raw_text"] = self.raw_text
        return data

    def to_csv_row(self) -> dict:
        return {
            "receipt_id": self.receipt_id,
            "category": self.category or "",
            "source_type": self.source_type or "",
            "date": self.date or "",
            "amount": _decimal_to_string(self.amount) or "",
            "cumulative_amount": _decimal_to_string(self.cumulative_amount) or "",
            "contributor_name": self.contributor_name or "",
            "contributor_last_name": self.contributor_last_name or "",
            "contributor_first_name": self.contributor_first_name or "",
            "occupation": self.occupation or "",
            "employer": self.employer or "",
            "address": " | ".join(self.address_lines),
            "fundraising_event": self.fundraising_event or "",
            "employer_address": " | ".join(self.employer_address),
            "page_number": str(self.page_number or ""),
            "extra": json.dumps(self.extra) if self.extra else "",
        }


@dataclass
class InKindContributionEntry:
    receipt_id: str
    category: Optional[str] = None
    source_type: Optional[str] = None
    date: Optional[str] = None
    amount: Optional[Decimal] = None
    cumulative_amount: Optional[Decimal] = None
    contributor_name: Optional[str] = None
    contributor_last_name: Optional[str] = None
    contributor_first_name: Optional[str] = None
    occupation: Optional[str] = None
    employer: Optional[str] = None
    address_lines: List[str] = field(default_factory=list)
    employer_address: List[str] = field(default_factory=list)
    description: Optional[str] = None
    limitation_type: Optional[str] = None
    fundraising_event_name: Optional[str] = None
    fundraising_event_address: List[str] = field(default_factory=list)
    page_number: Optional[int] = None
    extra: dict = field(default_factory=dict)
    raw_text: Optional[str] = None

    def to_json_dict(self, include_raw: bool = False) -> dict:
        data = {
            "receipt_id": self.receipt_id,
            "category": self.category,
            "source_type": self.source_type,
            "date": self.date,
            "amount": _decimal_to_string(self.amount),
            "cumulative_amount": _decimal_to_string(self.cumulative_amount),
            "contributor_name": self.contributor_name,
            "contributor_last_name": self.contributor_last_name,
            "contributor_first_name": self.contributor_first_name,
            "occupation": self.occupation,
            "employer": self.employer,
            "address_lines": self.address_lines,
            "employer_address": self.employer_address,
            "description": self.description,
            "limitation_type": self.limitation_type,
            "fundraising_event_name": self.fundraising_event_name,
            "fundraising_event_address": self.fundraising_event_address,
            "page_number": self.page_number,
        }
        if self.extra:
            data["extra"] = self.extra
        if include_raw:
            data["raw_text"] = self.raw_text
        return data

    def to_csv_row(self) -> dict:
        return {
            "receipt_id": self.receipt_id,
            "category": self.category or "",
            "source_type": self.source_type or "",
            "date": self.date or "",
            "amount": _decimal_to_string(self.amount) or "",
            "cumulative_amount": _decimal_to_string(self.cumulative_amount) or "",
            "contributor_name": self.contributor_name or "",
            "contributor_last_name": self.contributor_last_name or "",
            "contributor_first_name": self.contributor_first_name or "",
            "occupation": self.occupation or "",
            "employer": self.employer or "",
            "address": " | ".join(self.address_lines),
            "employer_address": " | ".join(self.employer_address),
            "description": self.description or "",
            "limitation_type": self.limitation_type or "",
            "fundraising_event_name": self.fundraising_event_name or "",
            "fundraising_event_address": " | ".join(self.fundraising_event_address),
            "page_number": str(self.page_number or ""),
            "extra": json.dumps(self.extra) if self.extra else "",
        }


@dataclass
class OtherReceiptEntry:
    receipt_id: str
    category: Optional[str] = None
    date: Optional[str] = None
    amount: Optional[Decimal] = None
    name: Optional[str] = None
    address_lines: List[str] = field(default_factory=list)
    fundraising_event_name: Optional[str] = None
    fundraising_event_address: List[str] = field(default_factory=list)
    refund_rebate_type: Optional[str] = None
    page_number: Optional[int] = None
    extra: dict = field(default_factory=dict)
    raw_text: Optional[str] = None

    def to_json_dict(self, include_raw: bool = False) -> dict:
        data = {
            "receipt_id": self.receipt_id,
            "category": self.category,
            "date": self.date,
            "amount": _decimal_to_string(self.amount),
            "name": self.name,
            "address_lines": self.address_lines,
            "fundraising_event_name": self.fundraising_event_name,
            "fundraising_event_address": self.fundraising_event_address,
            "refund_rebate_type": self.refund_rebate_type,
            "page_number": self.page_number,
        }
        if self.extra:
            data["extra"] = self.extra
        if include_raw:
            data["raw_text"] = self.raw_text
        return data

    def to_csv_row(self) -> dict:
        return {
            "receipt_id": self.receipt_id,
            "category": self.category or "",
            "date": self.date or "",
            "amount": _decimal_to_string(self.amount) or "",
            "name": self.name or "",
            "address": " | ".join(self.address_lines),
            "fundraising_event_name": self.fundraising_event_name or "",
            "fundraising_event_address": " | ".join(self.fundraising_event_address),
            "refund_rebate_type": self.refund_rebate_type or "",
            "page_number": str(self.page_number or ""),
            "extra": json.dumps(self.extra) if self.extra else "",
        }


@dataclass
class FundraiserEntry:
    fundraiser_id: str
    event_type: Optional[str] = None
    date_of_event: Optional[str] = None
    gross_receipts: Optional[Decimal] = None
    location_name: Optional[str] = None
    location_address: List[str] = field(default_factory=list)
    private_residence: Optional[bool] = None
    number_of_attendees: Optional[int] = None
    incidental_event_amount: Optional[Decimal] = None
    total_contributions: Optional[Decimal] = None
    co_sponsor: Optional[str] = None
    contribution_split_percent: Optional[str] = None
    expenditure_split_percent: Optional[str] = None
    page_number: Optional[int] = None
    extra: dict = field(default_factory=dict)
    raw_text: Optional[str] = None

    def to_json_dict(self, include_raw: bool = False) -> dict:
        data = {
            "fundraiser_id": self.fundraiser_id,
            "event_type": self.event_type,
            "date_of_event": self.date_of_event,
            "gross_receipts": _decimal_to_string(self.gross_receipts),
            "location_name": self.location_name,
            "location_address": self.location_address,
            "private_residence": self.private_residence,
            "number_of_attendees": self.number_of_attendees,
            "incidental_event_amount": _decimal_to_string(self.incidental_event_amount),
            "total_contributions": _decimal_to_string(self.total_contributions),
            "co_sponsor": self.co_sponsor,
            "contribution_split_percent": self.contribution_split_percent,
            "expenditure_split_percent": self.expenditure_split_percent,
            "page_number": self.page_number,
        }
        if self.extra:
            data["extra"] = self.extra
        if include_raw:
            data["raw_text"] = self.raw_text
        return data

    def to_csv_row(self) -> dict:
        return {
            "fundraiser_id": self.fundraiser_id,
            "event_type": self.event_type or "",
            "date_of_event": self.date_of_event or "",
            "gross_receipts": _decimal_to_string(self.gross_receipts) or "",
            "location_name": self.location_name or "",
            "location_address": " | ".join(self.location_address),
            "private_residence": "" if self.private_residence is None else ("Yes" if self.private_residence else "No"),
            "number_of_attendees": str(self.number_of_attendees or ""),
            "incidental_event_amount": _decimal_to_string(self.incidental_event_amount) or "",
            "total_contributions": _decimal_to_string(self.total_contributions) or "",
            "co_sponsor": self.co_sponsor or "",
            "contribution_split_percent": self.contribution_split_percent or "",
            "expenditure_split_percent": self.expenditure_split_percent or "",
            "page_number": str(self.page_number or ""),
            "extra": json.dumps(self.extra) if self.extra else "",
        }


@dataclass
class ExpenditureEntry:
    expense_id: str
    category: Optional[str] = None
    date: Optional[str] = None
    amount: Optional[Decimal] = None
    name: Optional[str] = None
    address_lines: List[str] = field(default_factory=list)
    fundraising_event_name: Optional[str] = None
    fundraising_event_location: List[str] = field(default_factory=list)
    description: Optional[str] = None
    support_or_campaign: Optional[str] = None
    expense_type: Optional[str] = None
    page_number: Optional[int] = None
    extra: dict = field(default_factory=dict)
    raw_text: Optional[str] = None

    def to_json_dict(self, include_raw: bool = False) -> dict:
        data = {
            "expense_id": self.expense_id,
            "category": self.category,
            "date": self.date,
            "amount": _decimal_to_string(self.amount),
            "name": self.name,
            "address_lines": self.address_lines,
            "fundraising_event_name": self.fundraising_event_name,
            "fundraising_event_location": self.fundraising_event_location,
            "description": self.description,
            "support_or_campaign": self.support_or_campaign,
            "expense_type": self.expense_type,
            "page_number": self.page_number,
        }
        if self.extra:
            data["extra"] = self.extra
        if include_raw:
            data["raw_text"] = self.raw_text
        return data

    def to_csv_row(self) -> dict:
        return {
            "expense_id": self.expense_id,
            "category": self.category or "",
            "date": self.date or "",
            "amount": _decimal_to_string(self.amount) or "",
            "name": self.name or "",
            "address": " | ".join(self.address_lines),
            "fundraising_event_name": self.fundraising_event_name or "",
            "fundraising_event_location": " | ".join(self.fundraising_event_location),
            "description": self.description or "",
            "support_or_campaign": self.support_or_campaign or "",
            "expense_type": self.expense_type or "",
            "page_number": str(self.page_number or ""),
            "extra": json.dumps(self.extra) if self.extra else "",
        }


class ReportParser:
    def __init__(self, pdf_path: Path):
        self.pdf_path = pdf_path
        self.reader = PdfReader(str(pdf_path))

    def _collect_contribution_pages(self) -> List[Tuple[int, str]]:
        pages: List[Tuple[int, str]] = []
        in_contributions = False

        for idx, page in enumerate(self.reader.pages):
            text = page.extract_text() or ""
            if ("Contributions Schedule" in text) and ("In-Kind Contributions Schedule" not in text):
                in_contributions = True
            if in_contributions:
                if (
                    ("Other Receipts Schedule" in text and "Contributions Schedule" not in text)
                    or "In-Kind Contributions Schedule" in text
                    or "Fundraisers Schedule" in text
                ):
                    break
                if "Direct Expenditures Schedule" in text:
                    break
                pages.append((idx, text))
        return pages

    def _collect_in_kind_pages(self) -> List[Tuple[int, str]]:
        pages: List[Tuple[int, str]] = []
        in_in_kind = False

        for idx, page in enumerate(self.reader.pages):
            text = page.extract_text() or ""
            if "In-Kind Contributions Schedule" in text:
                in_in_kind = True
            if in_in_kind:
                if "Fundraisers Schedule" in text and "In-Kind Contributions Schedule" not in text:
                    break
                if "Direct Expenditures Schedule" in text and "In-Kind Contributions Schedule" not in text:
                    break
                pages.append((idx, text))
        return pages

    def _collect_other_receipt_pages(self) -> List[Tuple[int, str]]:
        pages: List[Tuple[int, str]] = []
        in_other_receipts = False

        for idx, page in enumerate(self.reader.pages):
            text = page.extract_text() or ""
            if "Other Receipts Schedule" in text:
                in_other_receipts = True
            if in_other_receipts:
                if "In-Kind Contributions Schedule" in text and "Other Receipts Schedule" not in text:
                    break
                if "Fundraisers Schedule" in text and "Other Receipts Schedule" not in text:
                    break
                if "Direct Expenditures Schedule" in text and "Other Receipts Schedule" not in text:
                    break
                pages.append((idx, text))
        return pages

    def _collect_fundraiser_pages(self) -> List[Tuple[int, str]]:
        pages: List[Tuple[int, str]] = []
        in_fundraisers = False

        for idx, page in enumerate(self.reader.pages):
            text = page.extract_text() or ""
            if "Fundraisers Schedule" in text:
                in_fundraisers = True
            if in_fundraisers:
                if "Direct Expenditures Schedule" in text and "Fundraisers Schedule" not in text:
                    break
                pages.append((idx, text))
        return pages

    def _collect_expenditure_pages(self) -> List[Tuple[int, str]]:
        pages: List[Tuple[int, str]] = []
        in_expenditures = False

        for idx, page in enumerate(self.reader.pages):
            text = page.extract_text() or ""
            if "Direct Expenditures Schedule" in text:
                in_expenditures = True
            if in_expenditures:
                pages.append((idx, text))
        return pages

    def parse_contributions(self) -> List[ContributionEntry]:
        pages = self._collect_contribution_pages()
        if not pages:
            logging.warning("No contribution pages located in %s", self.pdf_path)
            return []

        combined, positions, page_numbers = _combine_pages(pages)
        matches = list(_CONTRIBUTION_ENTRY_PATTERN.finditer(combined))
        contributions: List[ContributionEntry] = []

        for idx, match in enumerate(matches):
            entry_start = match.start()
            entry_end = matches[idx + 1].start() if idx + 1 < len(matches) else len(combined)
            entry_text = combined[entry_start:entry_end].strip()
            page_number = _locate_page(entry_start, positions, page_numbers)
            entry = self._parse_contribution_entry(entry_text, page_number)
            contributions.append(entry)

        return contributions

    def parse_in_kind_contributions(self) -> List[InKindContributionEntry]:
        pages = self._collect_in_kind_pages()
        if not pages:
            logging.info("No in-kind contribution pages located in %s", self.pdf_path)
            return []

        combined, positions, page_numbers = _combine_pages(pages)
        matches = list(_IN_KIND_ENTRY_PATTERN.finditer(combined))
        in_kind_entries: List[InKindContributionEntry] = []

        for idx, match in enumerate(matches):
            entry_start = match.start()
            entry_end = matches[idx + 1].start() if idx + 1 < len(matches) else len(combined)
            entry_text = combined[entry_start:entry_end].strip()
            page_number = _locate_page(entry_start, positions, page_numbers)
            entry = self._parse_in_kind_entry(entry_text, page_number)
            in_kind_entries.append(entry)

        return in_kind_entries

    def parse_other_receipts(self) -> List[OtherReceiptEntry]:
        pages = self._collect_other_receipt_pages()
        if not pages:
            logging.info("No other receipts pages located in %s", self.pdf_path)
            return []

        combined, positions, page_numbers = _combine_pages(pages)
        matches = list(_OTHER_RECEIPT_ENTRY_PATTERN.finditer(combined))
        other_receipts: List[OtherReceiptEntry] = []

        for idx, match in enumerate(matches):
            entry_start = match.start()
            entry_end = matches[idx + 1].start() if idx + 1 < len(matches) else len(combined)
            entry_text = combined[entry_start:entry_end].strip()
            page_number = _locate_page(entry_start, positions, page_numbers)
            entry = self._parse_other_receipt_entry(entry_text, page_number)
            other_receipts.append(entry)

        return other_receipts

    def parse_fundraisers(self) -> List[FundraiserEntry]:
        pages = self._collect_fundraiser_pages()
        if not pages:
            logging.info("No fundraiser pages located in %s", self.pdf_path)
            return []

        combined, positions, page_numbers = _combine_pages(pages)
        matches = list(_FUNDRAISER_ENTRY_PATTERN.finditer(combined))
        fundraisers: List[FundraiserEntry] = []

        for idx, match in enumerate(matches):
            entry_start = match.start()
            entry_end = matches[idx + 1].start() if idx + 1 < len(matches) else len(combined)
            entry_text = combined[entry_start:entry_end].strip()
            page_number = _locate_page(entry_start, positions, page_numbers)
            entry = self._parse_fundraiser_entry(entry_text, page_number)
            fundraisers.append(entry)

        return fundraisers

    def parse_expenditures(self) -> List[ExpenditureEntry]:
        pages = self._collect_expenditure_pages()
        if not pages:
            logging.warning("No direct expenditure pages located in %s", self.pdf_path)
            return []

        combined, positions, page_numbers = _combine_pages(pages)
        matches = list(_EXPENDITURE_ENTRY_PATTERN.finditer(combined))
        expenditures: List[ExpenditureEntry] = []

        for idx, match in enumerate(matches):
            entry_start = match.start()
            entry_end = matches[idx + 1].start() if idx + 1 < len(matches) else len(combined)
            entry_text = combined[entry_start:entry_end].strip()
            page_number = _locate_page(entry_start, positions, page_numbers)
            entry = self._parse_expenditure_entry(entry_text, page_number)
            expenditures.append(entry)

        return expenditures

    def _parse_contribution_entry(self, entry_text: str, page_number: int) -> ContributionEntry:
        lines = [_clean_line(line) for line in entry_text.splitlines() if _clean_line(line)]
        contribution = ContributionEntry(receipt_id="", page_number=page_number, raw_text=entry_text)
        context: Optional[str] = None
        skip_next = 0

        for idx, line in enumerate(lines):
            if skip_next:
                skip_next -= 1
                continue

            if line.startswith("Receipt ") and re.search(r"\d{2}-\d+", line):
                id_match = re.search(r"\d{2}-\d+", line)
                contribution.receipt_id = id_match.group(0) if id_match else ""
                context = None

            elif line.startswith("Receipt Category:") or line.startswith("Category:"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                consumed = 0
                next_idx = idx + 1
                if (not value) and next_idx < len(lines):
                    candidate = lines[next_idx]
                    if (
                        ":" not in candidate
                        and not candidate.startswith("Date ")
                        and not candidate.startswith("Receipt ")
                    ):
                        value = candidate.strip()
                        consumed += 1
                contribution.category = value or None
                source_idx = idx + 1 + consumed
                if source_idx < len(lines):
                    candidate = lines[source_idx]
                    if (
                        ":" not in candidate
                        and not candidate.startswith("Date ")
                        and not candidate.startswith("Receipt ")
                    ):
                        contribution.source_type = candidate.strip()
                        consumed += 1
                if consumed:
                    skip_next = consumed
                context = None

            elif line.startswith("Date "):
                match = _DATE_LINE_PATTERN.search(line)
                if match:
                    contribution.date = match.group(1)
                    contribution.amount = _parse_decimal(match.group(2))
                    contribution.cumulative_amount = _parse_decimal(match.group(3))
                else:
                    tokens = line.replace("Date", "").split()
                    if tokens:
                        contribution.date = tokens[0]
                    if "Amount:" in line:
                        try:
                            amount_value = line.split("Amount:", 1)[1].split()[0]
                            contribution.amount = _parse_decimal(amount_value)
                        except IndexError:
                            pass
                    if "Cumulative" in line:
                        cumulative_value = line.split("Cumulative", 1)[1].strip()
                        contribution.cumulative_amount = _parse_decimal(cumulative_value.split()[0])
                context = None

            elif line.startswith("Name:"):
                contribution.contributor_name = line.split(":", 1)[1].strip() or None
                context = "post_name"

            elif line.upper().startswith("OCCUP"):
                value = line.split(":", 1)[1].strip() if ":" in line else " ".join(line.split()[1:])
                label_token = "".join(ch for ch in line if ch.isalpha()).upper()
                if value:
                    contribution.occupation = (
                        f"{contribution.occupation} {value}".strip()
                        if contribution.occupation
                        else value
                    )
                    context = "occupation"
                else:
                    if label_token.startswith("OCCUP") and len(line.split()) <= 2:
                        context = "occupation_pending"
                    else:
                        context = "occupation"

            elif line.startswith("Employer"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                if (
                    not value
                    and idx + 1 < len(lines)
                    and ":" not in lines[idx + 1]
                    and not lines[idx + 1].startswith("Fundraising Event")
                ):
                    value = lines[idx + 1].strip()
                    skip_next = max(skip_next, 1)
                contribution.employer = value or None
                context = "employer"

            elif line.startswith("Description:"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                if not value and idx + 1 < len(lines) and ":" not in lines[idx + 1]:
                    value = lines[idx + 1].strip()
                    skip_next = max(skip_next, 1)
                if value:
                    contribution.extra["description"] = value
                context = None

            elif line.startswith("Limitation Type:"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                if value:
                    contribution.extra["limitation_type"] = value
                context = None

            elif line.startswith("Fundraising Event"):
                value = line.split(":", 1)[1].strip() if ":" in line else line[len("Fundraising Event") :].strip()
                if not value and idx + 1 < len(lines):
                    candidate = lines[idx + 1]
                    if ":" not in candidate and not _looks_like_address(candidate):
                        value = candidate.strip()
                        skip_next = max(skip_next, 1)
                        consumed = True
                contribution.fundraising_event = value or None
                context = None

            else:
                if context == "employer":
                    if (
                        ":" not in line
                        and not line.startswith("Fundraising Event")
                        and not _looks_like_address(line)
                    ):
                        contribution.employer = (
                            f"{contribution.employer} {line}".strip()
                            if contribution.employer
                            else line
                        )
                    else:
                        if _looks_like_address(line):
                            contribution.employer_address.append(line)
                            context = "employer_address"
                        else:
                            contribution.extra.setdefault("unparsed", []).append(line)
                            context = None
                    continue
                if context in {"occupation", "occupation_pending"}:
                    if _looks_like_address(line):
                        contribution.address_lines.append(line)
                        context = "address"
                    else:
                        addition = line.strip()
                        if addition:
                            contribution.occupation = (
                                f"{contribution.occupation} {addition}".strip()
                                if contribution.occupation
                                else addition
                            )
                            context = "occupation"
                    continue
                if context == "post_name":
                    if _looks_like_address(line):
                        contribution.address_lines.append(line)
                        context = "address"
                    else:
                        addition = line.strip()
                        if addition:
                            contribution.contributor_name = (
                                f"{contribution.contributor_name} {addition}".strip()
                                if contribution.contributor_name
                                else addition
                            )
                    continue
                if context == "address":
                    contribution.address_lines.append(line)
                    context = "address"
                elif context == "employer_address":
                    contribution.employer_address.append(line)
                elif _looks_like_address(line):
                    if contribution.employer:
                        contribution.employer_address.append(line)
                        context = "employer_address"
                    else:
                        contribution.address_lines.append(line)
                        context = "address"
                elif contribution.category and not contribution.source_type:
                    contribution.source_type = line
                else:
                    contribution.extra.setdefault("unparsed", []).append(line)

        unparsed = contribution.extra.get("unparsed")
        if unparsed:
            contribution.employer_address = unparsed + contribution.employer_address
            del contribution.extra["unparsed"]
            if not contribution.extra:
                contribution.extra = {}

        contribution.source_type = _normalize_source_type(contribution.source_type)
        last, first = _split_contributor_name(contribution.contributor_name)
        contribution.contributor_last_name = last
        contribution.contributor_first_name = first

        return contribution

    def _parse_in_kind_entry(self, entry_text: str, page_number: int) -> InKindContributionEntry:
        lines = [_clean_line(line) for line in entry_text.splitlines() if _clean_line(line)]
        entry = InKindContributionEntry(receipt_id="", page_number=page_number, raw_text=entry_text)
        context: Optional[str] = None
        skip_next = 0

        for idx, line in enumerate(lines):
            if skip_next:
                skip_next -= 1
                continue

            if line.startswith("Receipt ID:"):
                value = line.split(":", 1)[1].strip()
                entry.receipt_id = value.split()[0] if value else ""
                context = None

            elif line.startswith("Receipt Category:"):
                value = line.split(":", 1)[1].strip()
                consumed = 0
                if not value and idx + 1 < len(lines):
                    candidate = lines[idx + 1]
                    if (
                        ":" not in candidate
                        and not candidate.startswith("Date ")
                        and not candidate.startswith("Receipt ")
                    ):
                        value = candidate.strip()
                        consumed += 1
                entry.category = value or None
                source_idx = idx + 1 + consumed
                if source_idx < len(lines):
                    candidate = lines[source_idx]
                    if (
                        ":" not in candidate
                        and not candidate.startswith("Date ")
                        and not candidate.startswith("Receipt ")
                    ):
                        entry.source_type = candidate.strip()
                        consumed += 1
                if consumed:
                    skip_next = consumed
                context = None

            elif line.startswith("Date "):
                match = _DATE_LINE_PATTERN.search(line)
                if match:
                    entry.date = match.group(1)
                    entry.amount = _parse_decimal(match.group(2))
                    entry.cumulative_amount = _parse_decimal(match.group(3))
                else:
                    tokens = line.replace("Date", "").split()
                    if tokens:
                        entry.date = tokens[0]
                    if "Amount:" in line:
                        try:
                            amount_value = line.split("Amount:", 1)[1].split()[0]
                            entry.amount = _parse_decimal(amount_value)
                        except IndexError:
                            pass
                    if "Cumulative" in line:
                        cumulative_value = line.split("Cumulative", 1)[1].strip()
                        entry.cumulative_amount = _parse_decimal(cumulative_value.split()[0])
                context = None

            elif line.startswith("Name:"):
                entry.contributor_name = line.split(":", 1)[1].strip() or None
                context = "post_name"

            elif line.upper().startswith("OCCUP"):
                value = line.split(":", 1)[1].strip() if ":" in line else " ".join(line.split()[1:])
                label_token = "".join(ch for ch in line if ch.isalpha()).upper()
                if value:
                    entry.occupation = (
                        f"{entry.occupation} {value}".strip()
                        if entry.occupation
                        else value
                    )
                    context = "occupation"
                else:
                    if label_token.startswith("OCCUP") and len(line.split()) <= 2:
                        context = "occupation_pending"
                    else:
                        context = "occupation"

            elif line.startswith("Employer"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                if (
                    not value
                    and idx + 1 < len(lines)
                    and ":" not in lines[idx + 1]
                    and not lines[idx + 1].startswith("Fundraising Event")
                ):
                    value = lines[idx + 1].strip()
                    skip_next = max(skip_next, 1)
                entry.employer = value or None
                context = "employer"

            elif line.startswith("Description"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                if value:
                    entry.description = (
                        f"{entry.description} {value}".strip()
                        if entry.description
                        else value
                    )
                context = "description"

            elif line.startswith("Limitation Type:"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                if value:
                    entry.limitation_type = value
                context = None

            elif line.startswith("Fundraising Event Name"):
                previous_context = context
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                consumed = False
                if not value and idx + 1 < len(lines):
                    candidate = lines[idx + 1]
                    if ":" not in candidate and not _looks_like_address(candidate):
                        value = candidate.strip()
                        skip_next = max(skip_next, 1)
                        consumed = True
                entry.fundraising_event_name = value or None
                if value:
                    context = "fundraising_event"
                else:
                    context = previous_context if previous_context == "post_name" and not consumed else None

            else:
                if context == "employer":
                    if (
                        ":" not in line
                        and not line.startswith("Fundraising Event")
                        and not _looks_like_address(line)
                    ):
                        entry.employer = (
                            f"{entry.employer} {line}".strip()
                            if entry.employer
                            else line
                        )
                    else:
                        if _looks_like_address(line):
                            entry.employer_address.append(line)
                            context = "employer_address"
                        else:
                            entry.extra.setdefault("unparsed", []).append(line)
                            context = None
                    continue
                if context in {"occupation", "occupation_pending"}:
                    if _looks_like_address(line):
                        entry.address_lines.append(line)
                        context = "address"
                    else:
                        addition = line.strip()
                        if addition:
                            entry.occupation = (
                                f"{entry.occupation} {addition}".strip()
                                if entry.occupation
                                else addition
                            )
                            context = "occupation"
                    continue
                if context == "post_name":
                    if _looks_like_address(line):
                        entry.address_lines.append(line)
                        context = "address"
                    else:
                        addition = line.strip()
                        if addition:
                            entry.contributor_name = (
                                f"{entry.contributor_name} {addition}".strip()
                                if entry.contributor_name
                                else addition
                            )
                    continue
                if context == "address":
                    entry.address_lines.append(line)
                    context = "address"
                elif context == "employer_address":
                    entry.employer_address.append(line)
                elif context == "description":
                    addition = line.strip()
                    if addition:
                        entry.description = (
                            f"{entry.description} {addition}".strip()
                            if entry.description
                            else addition
                        )
                elif context == "fundraising_event":
                    if _looks_like_address(line):
                        entry.fundraising_event_address.append(line)
                    else:
                        addition = line.strip()
                        if addition:
                            entry.fundraising_event_name = (
                                f"{entry.fundraising_event_name} {addition}".strip()
                                if entry.fundraising_event_name
                                else addition
                            )
                elif _looks_like_address(line):
                    if entry.employer:
                        entry.employer_address.append(line)
                        context = "employer_address"
                    else:
                        entry.address_lines.append(line)
                        context = "address"
                elif entry.category and not entry.source_type:
                    entry.source_type = line
                else:
                    entry.extra.setdefault("unparsed", []).append(line)

        unparsed = entry.extra.get("unparsed")
        if unparsed:
            entry.employer_address = unparsed + entry.employer_address
            del entry.extra["unparsed"]
            if not entry.extra:
                entry.extra = {}

        entry.source_type = _normalize_source_type(entry.source_type)
        last, first = _split_contributor_name(entry.contributor_name)
        entry.contributor_last_name = last
        entry.contributor_first_name = first

        return entry

    def _parse_fundraiser_entry(self, entry_text: str, page_number: int) -> FundraiserEntry:
        lines = [_clean_line(line) for line in entry_text.splitlines() if _clean_line(line)]
        entry = FundraiserEntry(fundraiser_id="", page_number=page_number, raw_text=entry_text)
        context: Optional[str] = None
        skip_next = 0

        for idx, line in enumerate(lines):
            if skip_next:
                skip_next -= 1
                continue

            if line.startswith("Fundraiser ID:"):
                entry.fundraiser_id = line.split(":", 1)[1].strip().split()[0]
                context = None

            elif line.startswith("Type of Event"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                if not value and idx + 1 < len(lines):
                    candidate = lines[idx + 1]
                    if ":" not in candidate and not _looks_like_address(candidate):
                        value = candidate.strip()
                        skip_next = max(skip_next, 1)
                entry.event_type = value or None
                context = None

            elif line.startswith("Date of Event"):
                entry.date_of_event = line.split(":", 1)[1].strip() or None
                context = None

            elif line.startswith("Gross Receipts"):
                match = re.search(r"([\d,]+\.\d{2})", line)
                if match:
                    entry.gross_receipts = _parse_decimal(match.group(1))
                context = "location_address"

            elif line.startswith("Private Residence"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                if value:
                    normalized = value.strip().upper()
                    entry.private_residence = normalized in {"Y", "YES", "TRUE", "1", "X"}
                    if normalized in {"N", "NO"}:
                        entry.private_residence = False
                context = None

            elif line.startswith("Number of Attendees"):
                match = re.search(r"\d+", line.replace(",", ""))
                if match:
                    try:
                        entry.number_of_attendees = int(match.group(0))
                    except ValueError:
                        pass
                context = None

            elif line.startswith("Incidental Event"):
                match = re.search(r"([\d,]+\.\d{2})", line)
                if match:
                    entry.incidental_event_amount = _parse_decimal(match.group(1))
                context = None

            elif line.startswith("Total Contributions"):
                match = re.search(r"([\d,]+\.\d{2})", line)
                if match:
                    entry.total_contributions = _parse_decimal(match.group(1))
                context = None

            elif line.startswith("Location"):
                value = ""
                if ":" in line:
                    value = line.split(":", 1)[1].strip()
                else:
                    value = line[len("Location") :].strip()
                if not value and idx + 1 < len(lines):
                    candidate = lines[idx + 1]
                    if (
                        ":" not in candidate
                        and not _looks_like_address(candidate)
                        and not candidate.startswith("Fundraiser ID:")
                    ):
                        value = candidate.strip()
                        skip_next = max(skip_next, 1)
                entry.location_name = value or entry.location_name
                context = None

            elif line.startswith("Co-Sponsor"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                if not value and idx + 1 < len(lines):
                    candidate = lines[idx + 1]
                    if ":" not in candidate and not _looks_like_address(candidate):
                        value = candidate.strip()
                        skip_next = max(skip_next, 1)
                entry.co_sponsor = value or None
                context = None

            elif line.startswith("Contribution Split %"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                entry.contribution_split_percent = value or None
                context = None

            elif line.startswith("Expenditure Split %"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                entry.expenditure_split_percent = value or None
                context = None

            else:
                if context == "location_address":
                    if line.startswith("Private Residence"):
                        context = None
                        entry.private_residence = True
                        continue
                    entry.location_address.append(line)
                    continue
                entry.extra.setdefault("unparsed", []).append(line)

        unparsed = entry.extra.get("unparsed")
        if unparsed:
            remaining = []
            for token in unparsed:
                normalized = token.strip().upper()
                if normalized == "X" and entry.private_residence is None:
                    entry.private_residence = True
                elif entry.location_name and not _looks_like_address(token):
                    entry.location_name = f"{entry.location_name} {token}".strip()
                else:
                    remaining.append(token)
            if remaining:
                entry.extra["unparsed"] = remaining
            else:
                del entry.extra["unparsed"]
            if not entry.extra:
                entry.extra = {}

        if not entry.fundraiser_id:
            entry.extra.setdefault("unparsed", []).append("Missing fundraiser id")

        return entry

    def _parse_other_receipt_entry(self, entry_text: str, page_number: int) -> OtherReceiptEntry:
        lines = [_clean_line(line) for line in entry_text.splitlines() if _clean_line(line)]
        entry = OtherReceiptEntry(receipt_id="", page_number=page_number, raw_text=entry_text)
        context: Optional[str] = None
        skip_next = 0

        for idx, line in enumerate(lines):
            if skip_next:
                skip_next -= 1
                continue

            if line.startswith("Receipt ID:"):
                value = line.split(":", 1)[1].strip()
                entry.receipt_id = value.split()[0] if value else ""
                context = None

            elif line.startswith("Receipt Category:"):
                entry.category = line.split(":", 1)[1].strip() or None
                context = None

            elif line.startswith("Date"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                entry.date = value or None
                context = None

            elif line.startswith("Amount:"):
                entry.amount = _parse_decimal(line.split(":", 1)[1])
                context = None

            elif line.startswith("Name:"):
                entry.name = line.split(":", 1)[1].strip() or None
                context = "post_name"

            elif line.startswith("Fundraising Event Name"):
                previous_context = context
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                consumed = False
                if not value and idx + 1 < len(lines):
                    candidate = lines[idx + 1]
                    if ":" not in candidate and not _looks_like_address(candidate):
                        value = candidate.strip()
                        skip_next = max(skip_next, 1)
                        consumed = True
                entry.fundraising_event_name = value or None
                if value:
                    context = "fundraising_event"
                else:
                    context = previous_context if not consumed else previous_context

            elif line.startswith("Refund/Rebate"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                entry.refund_rebate_type = value or None
                context = None

            else:
                if context == "post_name":
                    if _looks_like_address(line):
                        entry.address_lines.append(line)
                        context = "address"
                    else:
                        addition = line.strip()
                        if addition:
                            entry.name = (
                                f"{entry.name} {addition}".strip()
                                if entry.name
                                else addition
                            )
                    continue
                if context == "address":
                    entry.address_lines.append(line)
                    continue
                if context == "fundraising_event":
                    if _looks_like_address(line):
                        entry.fundraising_event_address.append(line)
                    else:
                        addition = line.strip()
                        if addition:
                            entry.fundraising_event_name = (
                                f"{entry.fundraising_event_name} {addition}".strip()
                                if entry.fundraising_event_name
                                else addition
                            )
                    continue
                if _looks_like_address(line):
                    entry.address_lines.append(line)
                else:
                    entry.extra.setdefault("unparsed", []).append(line)

        return entry

    def _parse_expenditure_entry(self, entry_text: str, page_number: int) -> ExpenditureEntry:
        lines = [_clean_line(line) for line in entry_text.splitlines() if _clean_line(line)]
        expenditure = ExpenditureEntry(expense_id="", page_number=page_number, raw_text=entry_text)
        context: Optional[str] = None
        skip_next = False

        for idx, line in enumerate(lines):
            if skip_next:
                skip_next = False
                continue

            if line.startswith("Expense ID:"):
                after_colon = line.split(":", 1)[1].strip()
                if idx + 1 < len(lines):
                    candidate = lines[idx + 1]
                    if re.fullmatch(r"[0-9-]+", candidate):
                        if after_colon.endswith("-"):
                            after_colon = f"{after_colon}{candidate}"
                        else:
                            after_colon = f"{after_colon} {candidate}"
                        skip_next = True
                cleaned_id = after_colon.strip()
                if cleaned_id.upper().endswith(" EXPENSE"):
                    cleaned_id = cleaned_id[: -len(" Expense")].rstrip()
                expenditure.expense_id = cleaned_id
                context = None

            elif line.startswith("Category:"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                if not value and idx + 1 < len(lines) and ":" not in lines[idx + 1]:
                    value = lines[idx + 1].strip()
                    skip_next = True
                expenditure.category = value or None
                context = None

            elif line.startswith("Date:"):
                expenditure.date = line.split(":", 1)[1].strip() or None
                context = None

            elif line.startswith("Amount:"):
                expenditure.amount = _parse_decimal(line.split(":", 1)[1])
                context = None

            elif line.startswith("Name:"):
                expenditure.name = line.split(":", 1)[1].strip() or None
                context = "post_name"

            elif line.startswith("Fundraising Event Name"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                if not value and idx + 1 < len(lines) and ":" not in lines[idx + 1]:
                    value = lines[idx + 1].strip()
                    skip_next = True
                expenditure.fundraising_event_name = value or None
                context = "event_address"

            elif line.startswith("Description"):
                value = line.split(":", 1)[1].strip() if ":" in line else ""
                if not value and idx + 1 < len(lines) and ":" not in lines[idx + 1]:
                    value = lines[idx + 1].strip()
                    skip_next = True
                expenditure.description = value or None
                context = "description"

            elif line.startswith("Type:"):
                value = line.split(":", 1)[1].strip()
                if not value and idx + 1 < len(lines) and ":" not in lines[idx + 1]:
                    value = lines[idx + 1].strip()
                    skip_next = True
                expenditure.expense_type = value or None
                context = None

            elif line.startswith("Support or"):
                combined = line
                if idx + 1 < len(lines) and ":" in lines[idx + 1]:
                    combined = f"{line} {lines[idx + 1]}"
                    skip_next = True
                if ":" in combined:
                    value = combined.split(":", 1)[1].strip()
                    expenditure.support_or_campaign = value or None
                else:
                    expenditure.support_or_campaign = combined
                context = None

            else:
                if line.upper() == "EXPENSE":
                    continue
                if context == "post_name":
                    if not expenditure.name:
                        expenditure.name = line
                    elif not _looks_like_address(line):
                        expenditure.name = f"{expenditure.name} {line}".strip()
                    else:
                        expenditure.address_lines.append(line)
                        context = "address"
                        continue
                elif context in {"address", "post_name"} or _looks_like_address(line):
                    expenditure.address_lines.append(line)
                    context = "address"
                elif context == "event_address":
                    expenditure.fundraising_event_location.append(line)
                elif context == "description":
                    if expenditure.description:
                        expenditure.description = f"{expenditure.description} {line}".strip()
                    else:
                        expenditure.description = line
                else:
                    expenditure.extra.setdefault("unparsed", []).append(line)

        unparsed_extra = expenditure.extra.get("unparsed")
        if unparsed_extra:
            extra_text = " ".join(unparsed_extra)
            if expenditure.description:
                expenditure.description = f"{expenditure.description} {extra_text}".strip()
            else:
                expenditure.description = extra_text
            del expenditure.extra["unparsed"]
            if not expenditure.extra:
                expenditure.extra = {}

        return expenditure


def _write_json(entries: Iterable, path: Path, include_raw: bool) -> None:
    payload = [entry.to_json_dict(include_raw=include_raw) for entry in entries]
    path.write_text(json.dumps(payload, indent=2), encoding="utf-8")
    logging.info("Wrote %s", path)


def _write_csv(fieldnames: Sequence[str], rows: Iterable[dict], path: Path) -> None:
    with path.open("w", newline="", encoding="utf-8") as handle:
        writer = csv.DictWriter(handle, fieldnames=fieldnames)
        writer.writeheader()
        for row in rows:
            writer.writerow(row)
    logging.info("Wrote %s", path)


def _build_arg_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Extract contribution and direct expenditure data from a Michigan campaign finance PDF."
    )
    parser.add_argument("pdf_path", type=Path, help="Path to the 'Candidate Report View and Schedules' PDF.")
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path("parsed_output"),
        help="Directory where JSON/CSV files will be written (default: %(default)s).",
    )
    parser.add_argument(
        "--formats",
        nargs="+",
        choices=("json", "csv"),
        default=["json", "csv"],
        help="One or more output formats to emit (default: json csv).",
    )
    parser.add_argument(
        "--include-raw",
        action="store_true",
        help="Include the original text block for each entry in the output.",
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable debug logging during parsing.",
    )
    return parser


def main(args: Optional[Sequence[str]] = None) -> None:
    parser = _build_arg_parser()
    parsed_args = parser.parse_args(args=args)

    logging.basicConfig(
        level=logging.DEBUG if parsed_args.verbose else logging.INFO,
        format="%(levelname)s: %(message)s",
    )

    pdf_path: Path = parsed_args.pdf_path
    if not pdf_path.exists():
        parser.error(f"PDF not found: {pdf_path}")

    report_parser = ReportParser(pdf_path)
    contributions = report_parser.parse_contributions()
    other_receipts = report_parser.parse_other_receipts()
    in_kind_contributions = report_parser.parse_in_kind_contributions()
    fundraisers = report_parser.parse_fundraisers()
    expenditures = report_parser.parse_expenditures()

    parsed_args.output_dir.mkdir(parents=True, exist_ok=True)

    if "json" in parsed_args.formats:
        _write_json(contributions, parsed_args.output_dir / "contributions.json", parsed_args.include_raw)
        _write_json(other_receipts, parsed_args.output_dir / "other_receipts.json", parsed_args.include_raw)
        _write_json(in_kind_contributions, parsed_args.output_dir / "in_kind_contributions.json", parsed_args.include_raw)
        _write_json(fundraisers, parsed_args.output_dir / "fundraisers.json", parsed_args.include_raw)
        _write_json(expenditures, parsed_args.output_dir / "expenditures.json", parsed_args.include_raw)

    if "csv" in parsed_args.formats:
        contrib_csv = parsed_args.output_dir / "contributions.csv"
        other_receipts_csv = parsed_args.output_dir / "other_receipts.csv"
        inkind_csv = parsed_args.output_dir / "in_kind_contributions.csv"
        fundraisers_csv = parsed_args.output_dir / "fundraisers.csv"
        exp_csv = parsed_args.output_dir / "expenditures.csv"
        _write_csv(
            [
                "receipt_id",
                "category",
                "source_type",
                "date",
                "amount",
                "cumulative_amount",
                "contributor_name",
                "contributor_last_name",
                "contributor_first_name",
                "occupation",
                "employer",
                "address",
                "fundraising_event",
                "employer_address",
                "page_number",
                "extra",
            ],
            (entry.to_csv_row() for entry in contributions),
            contrib_csv,
        )
        _write_csv(
            [
                "receipt_id",
                "category",
                "date",
                "amount",
                "name",
                "address",
                "fundraising_event_name",
                "fundraising_event_address",
                "refund_rebate_type",
                "page_number",
                "extra",
            ],
            (entry.to_csv_row() for entry in other_receipts),
            other_receipts_csv,
        )
        _write_csv(
            [
                "receipt_id",
                "category",
                "source_type",
                "date",
                "amount",
                "cumulative_amount",
                "contributor_name",
                "contributor_last_name",
                "contributor_first_name",
                "occupation",
                "employer",
                "address",
                "employer_address",
                "description",
                "limitation_type",
                "fundraising_event_name",
                "fundraising_event_address",
                "page_number",
                "extra",
            ],
            (entry.to_csv_row() for entry in in_kind_contributions),
            inkind_csv,
        )
        _write_csv(
            [
                "fundraiser_id",
                "event_type",
                "date_of_event",
                "gross_receipts",
                "location_name",
                "location_address",
                "private_residence",
                "number_of_attendees",
                "incidental_event_amount",
                "total_contributions",
                "co_sponsor",
                "contribution_split_percent",
                "expenditure_split_percent",
                "page_number",
                "extra",
            ],
            (entry.to_csv_row() for entry in fundraisers),
            fundraisers_csv,
        )
        _write_csv(
            [
                "expense_id",
                "category",
                "date",
                "amount",
                "name",
                "address",
                "fundraising_event_name",
                "fundraising_event_location",
                "description",
                "support_or_campaign",
                "expense_type",
                "page_number",
                "extra",
            ],
            (entry.to_csv_row() for entry in expenditures),
            exp_csv,
        )

    logging.info(
        "Parsed %d direct contribution entries, %d other receipt entries, %d in-kind contribution entries, %d fundraiser entries, and %d expenditure entries.",
        len(contributions),
        len(other_receipts),
        len(in_kind_contributions),
        len(fundraisers),
        len(expenditures),
    )


if __name__ == "__main__":
    main()
